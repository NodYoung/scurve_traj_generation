#!/usr/bin/env python
from matplotlib import pyplot as plt
import numpy as np
import rosbag
import sys

def get_waypoints(bag_name):
    bag = rosbag.Bag(bag_name, 'r')
    waypoints = None
    for topic, msg, t in bag.read_messages():
        print "Number of waypoints: ", len(msg.goal.trajectory.joint_trajectory.points)
        waypoints = msg.goal.trajectory.joint_trajectory.points
    bag.close()

    positions = np.array([])
    velocities = np.array([])
    accelerations = np.array([])
    times = np.array([])
    for wp in waypoints:
        if(positions.size == 0):
            positions = np.array(wp.positions)
            velocities = np.array(wp.velocities)
            accelerations = np.array(wp.accelerations)
        else:
            positions = np.vstack((positions, np.array(wp.positions)))
            velocities = np.vstack((velocities, np.array(wp.velocities)))
            accelerations = np.vstack((accelerations, np.array(wp.accelerations)))
        times = np.append(times, wp.time_from_start.to_sec())
    return (positions, velocities, accelerations, times)

def calc_derivative_from_sequence(sequence, times):
    derivatives = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
    for i in range(len(sequence)-1):
        if times[i+1] - times[i] == 0:
            print "time delta is 0! skipping derivative"
            derivative = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
        else:
            derivative = np.array([])
            for j in range(len(sequence[i])):
                derivative = np.append(derivative, (sequence[i+1][j] - sequence[i][j]) / (times[i+1] - times[i]))
        derivatives = np.vstack((derivatives, derivative))

    return derivatives

def get_fig_and_axes():
    fig, axes = plt.subplots(nrows=4, ncols=6, sharex=True, sharey=True)
    return fig, axes

def plot_waypoints(positions, velocities, accelerations, jerks, times, axes, color, marker):
    for i in range(6):
        axes[0, i].plot(times, [p[i] for p in positions], marker=marker, color=color)
        axes[1, i].plot(times, [v[i] for v in velocities], marker=marker, color=color)
        axes[2, i].plot(times, [a[i] for a in accelerations], marker=marker, color=color)
        axes[3, i].plot(times, [j[i] for j in jerks], marker=marker, color=color)

def fit_quintic_splines(positions, velocities, accelerations, times, stop=False):
    new_positions = np.array([])
    new_times = np.array([])
    for j in range(6):
        pos = np.array([])
        new_times = np.array([])
        t_last = 0
        for i in range(len(times) - 1):
            t1 = times[i]
            t2 = times[i+1]
            t1a = np.array([t1**5, t1**4, t1**3, t1**2, t1, 1])
            t2a = np.array([t2**5, t2**4, t2**3, t2**2, t2, 1])
            q = np.array([[ 1.0*t1a[0],  1.0*t1a[1],  1.0*t1a[2],  1.0*t1a[3],  1.0*t1a[4],  1.0*t1a[5]],
                          [ 5.0*t1a[1],  4.0*t1a[2],  3.0*t1a[3],  2.0*t1a[4],  1.0*t1a[5],         0.0],
                          [20.0*t1a[2], 12.0*t1a[3],  6.0*t1a[4],  2.0*t1a[5],         0.0,         0.0],
                          [ 1.0*t2a[0],  1.0*t2a[1],  1.0*t2a[2],  1.0*t2a[3],  1.0*t2a[4],  1.0*t2a[5]],
                          [ 5.0*t2a[1],  4.0*t2a[2],  3.0*t2a[3],  2.0*t2a[4],  1.0*t2a[5],         0.0],
                          [20.0*t2a[2], 12.0*t2a[3],  6.0*t2a[4],  2.0*t2a[5],         0.0,         0.0]])

            p1 = positions[i]
            p2 = positions[i+1]
            v1 = velocities[i]
            v2 = velocities[i+1]
            a1 = accelerations[i]
            a2 = accelerations[i+1]
            x = np.array([[ p1[j] ], # position
                          [  0.0  ], # velocity
                          [  0.0  ], # acceleration
                          [ p2[j] ], # position
                          [  0.0  ], # velocity
                          [  0.0  ]]) # acceleration
            if(not stop):
                x = np.array([[ p1[j] ], # position
                              [ v1[j] ], # velocity
                              [ a1[j] ], # acceleration
                              [ p2[j] ], # position
                              [ v2[j] ], # velocity
                              [ a2[j] ]]) # acceleration
            v = np.dot(np.linalg.inv(q), x).flatten()
            poly = np.poly1d(v)
            subset_times = np.arange(start=t_last+.008, stop=t2, step=.008)
            t_last = subset_times[-1]
            subset_pos = poly(subset_times)
            pos = np.concatenate((pos, subset_pos))
            new_times = np.concatenate((new_times, subset_times))

        if(new_positions.size == 0):
            new_positions = np.transpose(np.array([pos]))
        else:
            new_positions = np.hstack((new_positions, np.transpose(np.array([pos]))))
    new_velocities = calc_derivative_from_sequence(new_positions, new_times)
    new_accelerations = calc_derivative_from_sequence(new_velocities, new_times)
    new_jerks = calc_derivative_from_sequence(new_accelerations, new_times)

    return new_positions, new_velocities, new_accelerations, new_jerks, new_times





# Raw moveit trajectories (from rviz)
if(len(sys.argv) < 2):
    print "Err: add name of test script as command line arg"
    sys.exit()
(positions, velocities, accelerations, times) = get_waypoints(sys.argv[1])
jerks = calc_derivative_from_sequence(accelerations, times)

# Use naive method stopping at each waypoint to take the position trajectory and time parameterize appropriately (using quintic splines)
new_positions, new_velocities, new_accelerations, new_jerks, new_times = fit_quintic_splines(positions, velocities, accelerations, times, stop=True)
fig, axes = get_fig_and_axes()
plot_waypoints(positions, velocities, accelerations, jerks, times, axes, "red", "x")
plot_waypoints(new_positions, new_velocities, new_accelerations, new_jerks, new_times, axes, "blue", None)

# Use quintic splines, but with velocities/accelerations matching moveit's trajectory
new_positions, new_velocities, new_accelerations, new_jerks, new_times = fit_quintic_splines(positions, velocities, accelerations, times)
fig, axes = get_fig_and_axes()
plot_waypoints(positions, velocities, accelerations, jerks, times, axes, "red", "x")
plot_waypoints(new_positions, new_velocities, new_accelerations, new_jerks, new_times, axes, "blue", None)


plt.show()
