#!/usr/bin/env python
from matplotlib import pyplot as plt
import numpy as np
from numpy.polynomial import polynomial

blend_radius = 0.1

def fit_cubic(p0, p1, v0, v1):
    """
    Within a blend circle, we model the value of joint i as a cubic function:

        p_i(s) = a_i * s**3 + b_i * s**2 + c_i * s + d_i
        v_i(s) = 1/3 * a_i * s**2 + 1/2*b_i*s

    Note: while we use v_i to denote the "velocity" of joint i, it is with respect to
    the (somewhat arbitrary) variable "s" instead of time.

    The 2 position and two velocity constraints give us a system of 4 equations:

    """
    pass


# Test path
path = np.array([(0.0, 0.0), (1.0, 1.0), (1.5, 0.8), (-0.2, 0.4)])

# Plot path in 2D joint space
if 0:
    plt.plot([j[0] for j in path], [j[1] for j in path])
    for j in path[1:-1]:
        plt.gca().add_artist(plt.Circle((j[0], j[1]), blend_radius, color='r', fill=False))
    plt.gca().axis('equal')
    plt.show()

class Segment:
    def __init__(self, t0, jerk, acc0, vel0, pos0):
        """
        Jerk is assumed to be constant.
        """
        self.t0 = t0
        self.jerk = jerk
        self.acc0 = acc0
        self.vel0 = vel0
        self.pos0 = pos0

        self._acc_polynomial = np.array((acc0, jerk))
        self._vel_polynomial = np.polyint(self._acc_polynomial, k=[vel0])
        self._pos_polynomial = np.polyint(self._vel_polynomial, k=[pos0])

    def acc(self, t):
        return polynomial.polyval(t, self._acc_polynomial)

    def vel(self, t):
        return polynomial.polyval(t, self._vel_polynomial)

    def pos(self, t):
        return polynomial.polyval(t, self._pos_polynomial)

class PiecewiseTrajectory:
    def __init__(self, segments):
        self.segments = segments

    def chooseSegment(self, t):
        """
        Choose the segment that contains this time.
        """
        for seg in self.segments:
            if seg.t0 <= t:
                return seg
        return None

    def jerk(self, t):
        return self.chooseSegment(t).jerk(t)

    def acc(self, t):
        return self.chooseSegment(t).acc(t)

    def vel(self, t):
        return self.chooseSegment(t).vel(t)

    def pos(self, t):
        return self.chooseSegment(t).pos(t)

j_max = 1.0
a_max = 1.0
v_max = 3.0

p0 = 0.0
p7 = 30.0

t0 = 0.0
num_segments = 7
seg0 = Segment(0.0, j_max, 0.0, 0.0, p0)
t1 = a_max / j_max
seg1 = Segment(t1, 0.0, seg0.acc(t1), seg0.vel(t1), seg0.pos(t1))
t2 = t1 + (v_max - seg0.vel(t1) * 2.0) / a_max
trajectory = PiecewiseTrajectory([seg0])

times = np.linspace(t0, t2, 1000)
velocities = np.array([trajectory.segments[0].vel(t) for t in times])
plt.plot(times, velocities, 'x')
plt.show()
