#!/usr/bin/env python
from scipy import linalg
from matplotlib import pyplot as plt
import numpy as np
from numpy.polynomial import Polynomial
from sympy import Matrix, Piecewise, Symbol

def evaluate_piecewise(boundaries, functions, value, symbol):
    if value == boundaries[-1]:
        # For convenience, we include the final time in the last segment
        func_i = len(functions) - 1
    else:
        func_i = np.searchsorted(boundaries, value, side='right') - 1
    return np.array(functions[func_i].subs(symbol, value)).astype(np.float64).flatten()

class Segment:
    def __init__(self, jerk0, acc0, vel0, pos0):
        """
        Jerk is assumed to be constant.
        """
        self.jerk0 = jerk0
        self.acc0 = acc0
        self.vel0 = vel0
        self.pos0 = pos0

        self._acc_polynomial = Polynomial((acc0, jerk0))
        self._vel_polynomial = self._acc_polynomial.integ(k=vel0)
        self._pos_polynomial = self._vel_polynomial.integ(k=pos0)

    def jerk(self, t):
        return self.jerk0

    def acc(self, t):
        return self._acc_polynomial(t)

    def vel(self, t):
        return self._vel_polynomial(t)

    def pos(self, t):
        return self._pos_polynomial(t)

class PiecewiseTrajectory:
    def __init__(self, segment_boundary_times, segments):
        self.segment_boundary_times = np.asarray(segment_boundary_times, dtype=np.float64)
        self.segments = segments

    def chooseSegment(self, t):
        """
        Choose the segment that contains this time.
        """
        if t == self.segment_boundary_times[-1]:
            # For convenience, we include the final time in the last segment
            seg_i = len(self.segments) - 1
        else:
            seg_i = np.searchsorted(self.segment_boundary_times, t, side='right') - 1
        return self.segments[seg_i], self.segment_boundary_times[seg_i]

    def jerk(self, t):
        seg, seg_start_time = self.chooseSegment(t)
        return seg.jerk(t - seg_start_time)

    def acc(self, t):
        seg, seg_start_time = self.chooseSegment(t)
        return seg.acc(t - seg_start_time)

    def vel(self, t):
        seg, seg_start_time = self.chooseSegment(t)
        return seg.vel(t - seg_start_time)

    def pos(self, t):
        seg, seg_start_time = self.chooseSegment(t)
        return seg.pos(t - seg_start_time)

def fit_seven_segment(p_start, p_end, j_max, a_max, v_max):
    """
    Find the optimal seven segment trajectory for zero start and end velocities, and the given
    start and end positions.

    Follows the nomenclature and approach of

        Herrera-Aguilar, Ignacio, and Daniel Sidobre. "Soft motion trajectory planning and
        control for service manipulator robot." Workshop on Physical Human-Robot Interaction in
        Anthropic Domains at IROS. 2006.
    """
    assert(a_max > 0.0)
    assert(j_max > 0.0)
    assert(v_max > 0.0)

    # Maximum amount of time we can spend at any of our limit conditions before we violate the
    # next higher limit condition.
    T_jmax = a_max / j_max
    T_amax = v_max / a_max - a_max / j_max

    if T_amax < 0.0:
        # Using max positive jerk and then max negative jerk, we don't have time to
        # reach max acceleration before reaching max velocity. To account for this,
        # we adjust the max acceleration down to what we can actually reach on our way
        # to the max velocity, and we adjust the max time spent in the max jerk limited
        # section to just reach the new max acceleration.
        T_amax = 0.0
        T_jmax = (v_max / j_max)**0.5
        print(T_jmax, j_max)
        a_max = T_jmax * j_max

    # Compute the minimum distance that each case can travel. D_thr1 is the minimum distance for
    # a trajectory that hits both max acceleration. D_thr2 is the minimum distance for a
    # trajectory that hits max acceleration but not max velocity.
    #
    # Q: shouldn't there also be a case where v_max is reached but a_max is not, depending on the
    #    relation between v_max, a_max, and j_max?
    D_thr1 = (a_max * v_max) / j_max + v_max**2 / a_max
    D_thr2 = 2.0 * a_max**3 / j_max**2

    D = p_end - p_start
    if D >= D_thr1:
        # We hit both v_max and a_max
        print('Case 1')
        T_j = T_jmax
        T_a = T_amax
        T_v = (D - D_thr1) / v_max
    elif D > D_thr2:
        print('Case 2')
        # We hit a_max but not v_max
        T_v = 0.0
        T_j = T_jmax
        T_a = (a_max**2 / (4.0 * j_max) + D / a_max)**0.5 - 1.5 * a_max / j_max
    else:
        print('Case 3')
        # We hit neither a_max nor v_max
        T_v = 0.0
        T_a = 0.0
        T_j = (D / (2.0 * j_max))**(1.0 / 3.0)

    segment_jerks_and_durations = [(j_max, T_j), (0.0, T_a), (-j_max, T_j), (0.0, T_v), (-j_max,
        T_j), (0.0, T_a), (j_max, T_j)]
    segments = []
    p = p_start
    v = 0.0
    a = 0.0
    segment_boundary_times = [0.0]
    for j, T in segment_jerks_and_durations:
        segments.append(Segment(j, a, v, p))
        p = segments[-1].pos(T)
        v = segments[-1].vel(T)
        a = segments[-1].acc(T)
        segment_boundary_times.append(segment_boundary_times[-1] + T)
    return PiecewiseTrajectory(segment_boundary_times, segments)

def test_fit_seven_segment(p_start, p_end, j_max, a_max, v_max, plot=False):
    trajectory = fit_seven_segment(p_start, p_end, j_max, a_max, v_max)

    t_start = trajectory.segment_boundary_times[0]
    t_end = trajectory.segment_boundary_times[-1]
    p_start_actual = trajectory.pos(t_start)
    v_start_actual = trajectory.vel(t_start)
    p_end_actual = trajectory.pos(t_end)
    v_end_actual = trajectory.vel(t_end)
    print('Expected: {}  Actual: {}'.format((p_start, p_end, 0.0, 0.0), (p_start_actual,
        p_end_actual, v_start_actual, v_end_actual)))
    if plot:
        plot_trajectory(trajectory, j_max=j_max, a_max=a_max, v_max=v_max)

def plot_trajectory(trajectory, n_points=1000, j_max=None, a_max=None, v_max=None):
    plot_times = np.linspace(trajectory.segment_boundary_times[0],
            trajectory.segment_boundary_times[-1], 1000)
    positions = np.array([trajectory.pos(t) for t in plot_times])
    velocities = np.array([trajectory.vel(t) for t in plot_times])
    accelerations = np.array([trajectory.acc(t) for t in plot_times])
    jerks = np.array([trajectory.jerk(t) for t in plot_times])
    fig, axes = plt.subplots(4)
    axes[0].plot(plot_times, positions)
    axes[1].plot(plot_times, velocities)
    if v_max is not None:
        axes[1].plot(plot_times, [v_max] * len(plot_times), '--', color='red')
        axes[1].plot(plot_times, [-v_max] * len(plot_times), '--', color='red')
    axes[2].plot(plot_times, accelerations)
    if a_max is not None:
        axes[2].plot(plot_times, [a_max] * len(plot_times), '--', color='red')
        axes[2].plot(plot_times, [-a_max] * len(plot_times), '--', color='red')
    axes[3].plot(plot_times, jerks)
    if j_max is not None:
        axes[3].plot(plot_times, [j_max] * len(plot_times), '--', color='red')
        axes[3].plot(plot_times, [-j_max] * len(plot_times), '--', color='red')
    plt.show()

def parameterize_path(path):
    """
    Represent the given path as a function q_t = f(s).
    """
    s = Symbol('s')
    boundaries = [0.0]
    functions = []
    for q0, q1 in zip(path[:-1], path[1:]):
        q0 = Matrix(q0)
        q1 = Matrix(q1)
        s0 = boundaries[-1]
        length = (q1 - q0).norm()
        s1 = s0 + length
        direction = (q1 - q0) / length
        boundaries.append(float(s1))
        functions.append(q0 + direction * (s - s0))
    return boundaries, functions

def sample_path(boundaries, functions, symbol, npoints):
    S = np.linspace(boundaries[0], boundaries[-1], npoints)
    path_points = np.array([evaluate_piecewise(boundaries, functions, s, symbol) for s in S])
    return S, path_points

def plot_2d_path(boundaries, functions, symbol, npoints):
    S, path_points = sample_path(boundaries, functions, symbol, npoints)
    plt.plot(path_points[:,0], path_points[:,1], 'r.-')

# Test path
path = np.array([(0.0, 0.0), (1.0, 1.0), (1.5, 0.8), (-0.2, 0.4)])

# j_max, a_max, v_max, p_start, p_end
tests = [
        (0.1, 3.0, 0.1, 0.0, 30.0), # Reach max velocity bot not max acceleration
        (0.1, 3.0, 6.0, 0.0, 30.0), # Reach max acceleration but not max velocity
        (0.1, 2.3, 3.1, 0.0, 0.4), # Don't reach max velocity or max acceleration
        (0.1, 0.4, 2.0, 0.0, 30.0), # Reach max acceleration and also velocity
        ]

for j_max, a_max, v_max, p_start, p_end in tests:
    test_fit_seven_segment(p_start, p_end, j_max, a_max, v_max, False)

# Plot the last one
if 0:
    test_fit_seven_segment(p_start, p_end, j_max, a_max, v_max, True)

boundaries, functions = parameterize_path(path)

s = Symbol('s')
plot_2d_path(boundaries, functions, s, 100)
plt.plot([q[0] for q in path], [q[1] for q in path], 'bx')
plt.show()
